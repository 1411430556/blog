import{_ as s,c as a,o as i,a9 as e}from"./chunks/framework.42KYXCmH.js";const m=JSON.parse(`{"title":"运维 踩坑记录","description":"","frontmatter":{"outline":2,"head":[["script",{"charset":"UTF-8","id":"LA_COLLECT","src":"//sdk.51.la/js-sdk-pro.min.js"}],["script",{},"typeof LA !== 'undefined' && LA.init({\\"id\\":\\"3LNfUkScYzEz6k4D\\",\\"ck\\":\\"3LNfUkScYzEz6k4D\\",\\"hashMode\\":true})"]]},"headers":[],"relativePath":"pit/operation.md","filePath":"pit/operation.md","lastUpdated":1744625482000}`),n={name:"pit/operation.md"},p=e(`<h1 id="运维-踩坑记录" tabindex="-1">运维 踩坑记录 <a class="header-anchor" href="#运维-踩坑记录" aria-label="Permalink to &quot;运维 踩坑记录&quot;">​</a></h1><h2 id="vue项目部署后页面跳转正常-但是页面一刷新就报404" tabindex="-1"><code>vue</code>项目部署后页面跳转正常，但是页面一刷新就报<code>404</code> <a class="header-anchor" href="#vue项目部署后页面跳转正常-但是页面一刷新就报404" aria-label="Permalink to &quot;\`vue\`项目部署后页面跳转正常，但是页面一刷新就报\`404\`&quot;">​</a></h2><p><code>vue</code>项目本身运行正常，部署到服务器之后，页面跳转是正常的，但是跳转后一旦刷新页面，就会出现<code>404</code>错误，项目路由模式为<code>history</code>模式。</p><h4 id="问题原因" tabindex="-1">问题原因 <a class="header-anchor" href="#问题原因" aria-label="Permalink to &quot;问题原因&quot;">​</a></h4><p>当前几乎所有的项目都是前后端分离，对前端的部署来说，其实就是将构建之后的产物上传至目标服务器的<code>web</code>容器指定的静态目录下。出现<code>404</code>错误意味着资源不存在。</p><p>对<code>vue</code>来说，由于它是单页面应用，所有的路由切换都是通过动态重写当前页面来完成的。不管我们的页面有多少个路由页面，构建物都只会产出一个<code>index.html</code>文件。</p><p>看下我们的<code>nginx</code>的配置：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  listen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  server_name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  www.xxx.com</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    index</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  /data/dist/index.html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这段代码的意思是：当我们在地址栏输入<code> www.xxx.com</code> 时，如果域名后没有任何路由，这时会打开我们 dist 目录下的<code> index.html</code> 文件，然后根据我们在前端项目里的配置会自动跳转到 <code>www.xxx.com/login</code>。</p><p>之后若我们尝试在 <code>website.com/login </code>页执行刷新操作，<code>nginx location</code> 是没有相关配置的，所以就会出现 <code>404</code> 的情况。</p><p>产生问题的根本原因其实是因为：我们的路由是通过<code>JS</code>来执行视图切换的，当我们进入到子路由再刷新页面时，<code>web</code>容器没有相对应的页面，就会报<code>404</code>错误。</p><h4 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-label="Permalink to &quot;解决方法&quot;">​</a></h4><p>原因分析清楚了，解决的方法也就呼之欲出：我们只需要配置下<code>nginx</code>，把任何页面都重定向到<code>index.html</code>中，将路由解析的工作交给前端来处理</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  listen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  server_name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  www.xxx.com</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    index</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  /data/dist/index.html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    try_files</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $uri $uri</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /index.html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>这样做之后，当访问到不存在的路由时，服务器就不再返回站内<code>404</code>错误页面，因为对所有的路径都会返回<code>index/html</code>文件，这个时候前端需要写一个默认顶层的<code>404</code>页面来代替站内的<code>404</code>页面</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> routes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RouteRecordRaw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/:pathMatch(.*)*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;404&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@views/404.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></div><details class="details custom-block"><summary>为什么<code>hash</code>模式下没有问题？</summary><p><code>hash</code> 模式我们都知道是用符号<code>#</code>表示的，如 <code>website.com/#/login</code>, <code>hash </code>的值为 <code>#/login</code></p><p>它的特点在于：<code>hash</code> 虽然出现在 <code>URL</code> 中，但不会被包括在 <code>HTTP</code> 请求中，对服务端完全没有影响，因此改变 <code>hash</code> 不会重新加载页面</p><p><code>hash</code> 模式下，仅 <code>hash</code> 符号之前的内容会被包含在请求中，如 <code>website.com/#/login</code> 只有 <code>website.com</code> 会被包含在请求中 ，因此对于服务端来说，即使没有配置<code>location</code>，也不会返回<code>404</code>错误</p></details><h2 id="vue部署服务器之后访问部分路由白屏" tabindex="-1"><code>vue</code>部署服务器之后访问部分路由白屏 <a class="header-anchor" href="#vue部署服务器之后访问部分路由白屏" aria-label="Permalink to &quot;\`vue\`部署服务器之后访问部分路由白屏&quot;">​</a></h2><p><code>vue</code>项目本身运行正常，部署到服务器之后，访问部分路由会报白屏，项目路由模式为<code>history</code>模式</p><h4 id="问题原因-1" tabindex="-1">问题原因 <a class="header-anchor" href="#问题原因-1" aria-label="Permalink to &quot;问题原因&quot;">​</a></h4><p>如果在项目配置文件里，把里面的 <code>publicPath</code> （使用 <code>Vue CLI</code> ） 或者 <code>base</code> （使用 <code>Vite</code> ） 配置成相对路径 <code>./</code> ，但是路由配置了二级或以上，那么就会出现这个问题。</p><p>原因是打包后的 <code>JS</code> 、 <code>CSS</code> 等静态资源都是存放在项目根目录下，一级路由的 <code>./</code> 就是根目录，所以访问正常；而二级路由的 <code>./</code> 则不是根目录了，是从当前目录载入的 ，这就导致无法正确载入 <code>JS</code> 文件，从而导致了白屏。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>假设项目域名是 <code>https://example.com</code> ，一级路由是 <code>https://example.com/home</code>,二级路由是 <code>https://example.com/foo/bar</code>。</p><p>假设打包后的 JS 文件等静态资产存放于 <code>https://example.com/assets/</code> 文件夹下，访问一级路由时， <code>./</code> 访问到的 <code>JS</code> 文件是 <code>https://example.com/assets/home.js</code> ，所以一级路由可以正常访问到。</p><p>访问二级路由时， <code>./</code> 访问到的 <code>JS</code> 文件是 <code>https://example.com/foo/assets/bar.js</code> ，但实际上文件是存放在 <code>https://example.com/assets/bar.js</code> ，访问到的 URL 资源不存在，所以白屏了。</p></div><h4 id="解决方法-1" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法-1" aria-label="Permalink to &quot;解决方法&quot;">​</a></h4><p>如果的项目开启了 <code>History</code> 模式，并且配置有二级或者二级以上的路由时，不要使用 <code>./</code> 这样的相对路径。</p><p>正确的方式应该是修改 <code>publicPath</code> （使用 <code>Vue CLI</code> ） 或者 <code>base</code> （使用 <code>Vite</code> ），如果是部署在域名根目录则写 <code>/</code> ，如果是子目录，则按照子目录的格式，将其以 <code>/</code> 开头，以 <code>/</code> 结尾的形式配置（ <code>e.g. /hello-world/</code> ）</p>`,25),l=[p];function d(t,c,h,o,r,k){return i(),a("div",null,l)}const b=s(n,[["render",d]]);export{m as __pageData,b as default};
